Explanation of my functions


Dirac_oscillator.h:
constructor: sign,nodes,kappa,b,rmin,rmax,N
public data: E, upper ,lower(upper,lower are vectors of the radial part of wave function)
notes: I already choose M to be 939/197.326


States.cpp:
constructor:nodes,kappa,m,sign.
public data:n,k,sign,m,key.(key here is a string concatenate n,k,sign together with”.”.


Generate_state.h:
generate_statesm:return all the states with the same m(a vector of States)
parameters: m,max_l,nodes(default to 10,this number increase accuracy)
note: I choose kappa max to be 7+max_L


Integrator.h:
class my_spline:
constructor: y_array,x_array,Number of datas.(or just two vectors)
member_function: .integral()


simps.h:
simps(vector y,vector x):return the integral values based on this.(the size of the array has to be odd)


symm.h: //diagonalize the matrix
struct eig:
data:
double eigenvalues
vector<double> eigen_vectors;

matrix_diag(vector flat, int size): the size here is the length of matrix for one dimension.
member function:
get_results(): doesn’t return anything
public data:
results: a collection of all eigenvalues and eigenvectors pair


Solution.h:
struct eig2:
data:
	eig solution;
	double m;

struct coef_pair:
data:
	double coefs;
	State state;

struct solution_wave_function:
data:
	int kappa;
	vector<double> upper;
	vector<double> lower;

class Solution:
data:
	vector<coef_pair> my_pair;
	double m;
	double energy;
	vector<int> kappas;
	State primary_state;
	vector<solution_wave_function> wavefunctions;
member functions:
	Solution(eig2 result):  constructor
	bool add_kappa(int k):  add a kappa into the kappas
	void get_primary_state(): find primary state
	solution_wave_function get_wave_function(int kappa): return solution associated with that kappa
	get_all_wave_function(): get all wavefunctions


Density.h:
functions:
vector<Solution> get_solutions_object(vector<eig2> occ): return solution in the form of Solution class
vector<int> get_possible_L(k1,k2): given 2 kappa, return all possible L, parity clebsh is not considered here
		(int this header file, only used when we read the txt file, in that file, parity is already been considered)
void generate_density(…):get dens,denv,denp,den3 from the densities we get from class Density.

struct den:
data:
	vector<double> s
	vector<double> v

class Density:
data:
	vector<Solution> solution;
	vector<den> density
member functions:
	Density(vector<eig2>& occ): constructor from occ states, densities on every channel is initialized to 0s
	void append(den temp, int channel): append a partial density to specific channel
	void compute_one_(int a,int b,int num): compute a partial density according to a specific soluiton and two specific
		kappas in that solution.
	void compute():compute a partial density according to a specific solution
	vodi compute_all(): compute the total density according to all the solutions 
	

effecitve_density.h:
functions:
double tj_:three j symbol, need to find a method to link to fortran 
double pcg_: compute parity cg coeffs
vector<int> possilbe_L : get all possible_L when given 2 l
vector<vector<double>> multiplication: multiply two lengedre series together
void get_effective_density: dealing with the nonlinear term in CG coeffs
void get_potential: update the new potential with the density calculated before
void update_potential: the combination of the two functions before, for every big iteration, update potential twice!




main.cpp:
States_map:
	keys:states.key
	values:wave function(upper,lower)
Angular_map:
	keys:concatenation of m,k1,k2,L
	values: A(m,k1,k2,L)

preprocessing: construct the States_map and Angular_map
preprocessing2:Initialize the potentials: Phi W B A 
generatepotential:
	parameters: Phi  W  B A Potential Scalar_p Vector_p L particle_type
	results: get a scalar and vector potential depends on the particle_type
	






My Next step:
1.一个指针指向另一个数组会是什么结果？
find a better integrator
